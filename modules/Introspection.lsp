(context 'Introspection)

;; unicode chars are understood by both newLISP and JSON parsers
;; (http://www.json.org/)
(define (json-quote str)
  (replace "\\" str "\\\\")
  (replace "\"" str "\\\"")
  (replace "\n" str "\\n")
  (replace "\t" str "\\t")
  (replace "\r" str "\\r")
  (replace "\b" str "\\b")
  (replace "\f" str "\\f"))
;; there is no \v in newLISP (for "foo\vbar" \v silently becomes a v);
;; for "foo\011bar" (corresponds to \v) see below.

;; "\/" (slash) -> needed for JSON parsing (allowed as escape there), but not
;; for generating it (an unescaped '/' is allowed, too): as newlisp source it
;; becomes "\"foo\\/bar\"", which will be handled by first replace
;; (btw: '\' silently ignored in "foo\/bar" by newLISP parsing).

;; Translating some '\nnn' decimal ascii into unicode sequences; e.g. there is:
[text]
> (set 't "\000\001\002\003\004\005\006\007\008\009\010\011\012\013\014\015\016\017\018\019\020\021\022\023\024\025\026\027\028\029\030\031\032\033\034\035\036\037\038\039\040\041\042\043\044")
"\000\001\002\003\004\005\006\007\b\t\n\011\f\r\014\015\016\017\018\019\020\021\022\023\024\025\026\027\028\029\030\031 !\"#$%&'()*+,"
> (set 'u "\u0000\u0001\u0002\u0003\u0004")
"\000\001\002\003\004"
[/text]
;; (lower unicodes represented as newLISP \nnn sequences)
;; is *not* needed, because (source 'str) below leads to a representation
[text]
> (source 'u)
"(set 'u \"\\000\\001\\002\\003\\004\")\n\n"
[/text]
;; ; which will be handled by first replace (problem with unprintable chars
;; inside [text][/text] output remains, though).
;;
;; Missing:
;; - BOM handling as part of WS (webservice server code): not needed
;;   for Inspector so far.
;; Potential problems:
;; - binary data in strings may be invalid unicode: this could lead to problems.
;; - [text][/text] representation generated by :source omits unprintable chars
;;   -> this could lead to information loss.
;;
;; Note:
;; Do *not* know, if thought about *all* nasty cases: strings is
;; complicated (and somewhat boring).


(define (j-NL)  "\n")
(define (j-sNL) ",\n")
(define (j-sS)  ", ")
(define (j-S)   " ")

;; without indent
(define (j-key-valStr-noquote keyStr valStr)
  (append "\"" keyStr "\":" (j-S) "\"" valStr "\""))
(define (j-key-valStr keyStr valStr)
  (j-key-valStr-noquote keyStr (json-quote valStr)))
(define (j-key-valJSON keyStr valJSONStr)
  (append "\"" keyStr "\":" (j-S) valJSONStr))
(define (j-keyQuoted-valJSON keyStr valJSONStr)
  (j-key-valJSON (json-quote keyStr) valJSONStr))

;; with indent
(define (ji-key-valStr keyStr valStr)
  (append iis (j-key-valStr keyStr valStr)))
(define (ji-key-valStr-noquote keyStr valStr)
  (append iis (j-key-valStr-noquote keyStr valStr)))
(define (ji-key-valJSON keyStr valJSONStr) ; valJSON used always with indent
  (append iis (j-key-valJSON keyStr valJSONStr)))

(set 'minimalOutput nil)
(if minimalOutput
    ;; minimal versions omitting JSON whitespace
    (set 'indentPlusStr ""
         'ois ""
         'iis ""
         'j-NL (lambda () "")
         'j-sNL (lambda () ",")
         'j-sS (lambda () ",")
         'j-S (lambda () "")
         ;; switch indent off
         'ji-key-valStr j-key-valStr
         'ji-key-valStr-noquote j-key-valStr-noquote
         'ji-key-valJSON j-key-valJSON)
    (set 'indentPlusStr "  " ; mandatory
         'ois "" ; needed by ji-* funcs (if not switched off), if not called ..
         'iis "")) ; .. via json-str/json-expr (which sets them)


;; shortcuts without indent
(define (j-type typeStr)
  (j-key-valStr-noquote "type" typeStr))
(define (j-val-valStr-noquote valStr)
  (j-key-valStr-noquote "val" valStr))
(define (j-val-valStr valStr)
  (j-key-valStr "val" valStr))
;; shortcuts with indent
(define (ji-type typeStr)
  (ji-key-valStr-noquote "type" typeStr))
(define (ji-val-valStr valStr)
  (ji-key-valStr "val" valStr))
(define (ji-val-valJSON valJSONStr)
  (ji-key-valJSON "val" valJSONStr))


(define (toJSON-simple-noquote typeStr arg)
  (append "{" (j-S)
          (j-type typeStr) (j-sS) (j-val-valStr-noquote (string arg))
          (j-S) "}"))
(define (toJSON-simple typeStr arg)
  (append "{" (j-S)
          (j-type typeStr) (j-sS) (j-val-valStr (string arg))
          (j-S) "}"))
(define (toJSON-simple-multiline typeStr arg)
  (append "{" (j-NL)
          (ji-type typeStr) (j-sNL)
          (ji-val-valStr (string arg)) (j-NL)
          ois "}"))

(define (j-obj-content contentStr)
  (append "{"
          (j-NL)
          contentStr
          (j-NL)
          ois "}"))

(define (j-typeObj-content typeStr contentStr
                           , (iis (append ois indentPlusStr)))
  (j-obj-content
   (append
    iis (j-type typeStr)
    (j-sNL)
    contentStr)))

(define (json-for-sym s fromOrNil
                      , (iis (append ois indentPlusStr))
                        (prefix_term (Util:prefix-term-strings s))
                        (referenceFlag (!= (string (prefix s))
                                           (prefix_term 0))))
  (j-typeObj-content
   "sym"
   (append
    ;; iis indent
    (ji-key-valStr  "prefix"     (prefix_term 0))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valStr  "term"       (prefix_term 1))
    (j-sNL) ; with NL
    ;; iis indent
    (ji-key-valJSON "global?"    (if (global?    s) "true" "false"))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valJSON "protected?" (if (protected? s) "true" "false"))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valJSON "reference" (if referenceFlag "true" "false"))
    (if referenceFlag
        (append
         (j-sS) ; ', ' only
         ;; no indent
         (j-key-valStr "target" (string (prefix s))))
        "")
    ;; we are interested in val of sym, but we want to avoid infinite recursion:
    ;; - sym_1 -> sym_2 -> sym_1
    (if (not (symbol? fromOrNil))
        (append
         (j-sNL) ; NL
         ;; iis indent
         (ji-val-valJSON (json-str (eval s) s iis)))
        ""))))

(define (json-for-context c
                          , (iis (append ois indentPlusStr)))
  (j-typeObj-content
   "context"
   (append
    (ji-key-valStr     "term"    (term c))
    (j-sNL)
    ;; no creation of default (functor) sym
    (ji-key-valJSON "default" (if (Util:default? c)
                                  "true"
                                  "null")))))

(define (json-for-lambda l
                         , (iis (append ois indentPlusStr)))
  (toJSON-simple-multiline "lambda" l))

(define (json-for-macro m
                        , (iis (append ois indentPlusStr)))
  (toJSON-simple-multiline "macro" m))

(define (json-for-listOrArray typeStr loa
                              , (iis (append ois indentPlusStr)))
  (j-typeObj-content
   typeStr
   (append
    (ji-key-valJSON "length" (string (length loa))) (j-sNL)
    (ji-key-valStr "rep" (string loa)))))

(macro (json-for-list L)
  (json-for-listOrArray "list" L))
(macro (json-for-array A)
  (json-for-listOrArray "array" A))


;; example source: "(set 'str \"bar\\000buz\")\n\n"
;; problematic:
;; - [text] does not show unprintable chars!
(define (extract-from-source sourceStr
                             , ixStart ixEnd strRaw)
  (set 'ixEnd -3
       'ixStart (find "\"|\\[" sourceStr 0) ; beginning of "\"" or "[text]"
       'strRaw (ixStart ixEnd sourceStr))
  strRaw)
;;
;;
;; check for unprintable chars works, if MAIN:string omits them
;; - don't know how to elegantly print set val of MAIN:source
(define (json-for-string str
                         , (iis (append ois indentPlusStr))
                           strVal strLen sourceStr)
  (set 'strVal (string str)
       'strLen (length str))
  (set 'sourceStr (source 'str))
  ;;(dbg:expr sourceStr)
  (j-typeObj-content
   "string"
   (append
    (ji-key-valJSON "length" (string (length str))) (j-sNL)
    (ji-key-valStr "rep" (extract-from-source sourceStr))
    (if (= (length strVal) strLen)
        "" ; str seems to be normal
        (append ; this one may have problems and/or interesting features
         (j-sNL)
         (ji-key-valJSON "unprintable chars" "true"))))))

(macro (em-json Def-or-Defmac Fun)
  (Def-or-Defmac (Fun a fromOrNil
                      (ois "") ; outer indent string
                      (iis (append ois ; iis in shared use
                                   indentPlusStr)))
    ;(dbg:expr a (symbol? a) (macro? a))
    (append
     (cond
      ((integer? a)
       (toJSON-simple-noquote "integer" a))
      ((bigint? a)
       (toJSON-simple-noquote "bigint" a))
      ((float? a)
       (toJSON-simple-noquote "float" a))
      ((string? a)
       (json-for-string a iis))
      ((quote? a)
       (toJSON-simple-noquote "quote" a))
      ((lambda? a)
       (json-for-lambda a))
      ((array? a)
       (json-for-array a))
      ((primitive? a)
       (toJSON-simple-noquote "primitive" a))
      ((context? a)
       (json-for-context a))
      ;; seq counts here
      ((symbol? a)
       (json-for-sym a fromOrNil))
      ((macro? a) ;&& seq counts: macro? for em-macro sym is true
       (json-for-macro a))
      ((list? a) ; a macro is a list, too
       (json-for-list a)) ; may call back with increased indent
      ((nil? a) ; (nil? 'nil) -> true
       (toJSON-simple-noquote "nil" a))
      ((true? a) ; (true? 'true) -> true
       (toJSON-simple-noquote "true" a))
      ("default"
       (throw-error (string "should not happen, unknown argument: " a))
       (toJSON-simple-noquote "unknown" a))))))


(em-json define json-str)
(em-json define-macro json-expr)


(define (sym-actions s
                     , (prefixTerm (Util:prefix-term-strings s)))
  (extend res
          (j-keyQuoted-valJSON ; json-quote for 'nasty' symbol names
           (append (prefixTerm 0) ":" (prefixTerm 1))
           (json-str s))))

(define (symbols-to-JSON syms)
  (set 'res "")
  (if syms (sym-actions (first syms)))
  (dolist (s (rest syms))
          (extend res ",\n")
          (sym-actions s))
  (j-obj-content res))

(context MAIN)
;; EOF
