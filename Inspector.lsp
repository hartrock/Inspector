(load-lib 'WS)

(logg:level-warn)
;(dbg:off)


(context 'Inspector)
(set 'help
[text]Inspector to be started from interpreter by:
  (Inspector:start)
, and left from browser by loading:
  http://localhost:8080/leave
.
You can jump to a symbol by using its anchor; e.g. for jumping to MAIN:MAIN use:
  http://localhost:8080/symbols.html#MAIN:MAIN
.[/text])
;; unicode chars are understood by both newLISP and JSON parsers
;; (http://www.json.org/)
(define (json-quote str)
  (replace "\\" str "\\\\")
  (replace "\"" str "\\\"")
  (replace "\n" str "\\n")
  (replace "\t" str "\\t")
  (replace "\r" str "\\r")
  (replace "\b" str "\\b")
  (replace "\f" str "\\f"))
;; there is no \v in newLISP (for "foo\vbar" \v silently becomes a v);
;; for "foo\011bar" (corresponds to \v) see below.

;; "\/" (slash) -> needed for JSON parsing (allowed as escape there), but not
;; for generating it (an unescaped '/' is allowed, too): as newlisp source it
;; becomes "\"foo\\/bar\"", which will be handled by first replace
;; (btw: '\' silently ignored in "foo\/bar" by newLISP parsing).

;; Translating some '\nnn' decimal ascii into unicode sequences; e.g. there is:
[text]
> (set 't "\000\001\002\003\004\005\006\007\008\009\010\011\012\013\014\015\016\017\018\019\020\021\022\023\024\025\026\027\028\029\030\031\032\033\034\035\036\037\038\039\040\041\042\043\044")
"\000\001\002\003\004\005\006\007\b\t\n\011\f\r\014\015\016\017\018\019\020\021\022\023\024\025\026\027\028\029\030\031 !\"#$%&'()*+,"
> (set 'u "\u0000\u0001\u0002\u0003\u0004")
"\000\001\002\003\004"
[/text]
;; (lower unicodes represented as newLISP \nnn sequences)
;; is *not* needed, because (source 'str) below leads to a representation
[text]
> (source 'u)
"(set 'u \"\\000\\001\\002\\003\\004\")\n\n"
[/text]
;; ; which will be handled by first replace (problem with unprintable chars
;; inside [text][/text] output remains, though).
;;
;; Missing:
;; - BOM handling as part of WS (webservice server code): not needed
;;   for Inspector so far.
;; Potential problems:
;; - binary data in strings may be invalid unicode: this could lead to problems.
;; - [text][/text] representation generated by :source omits unprintable chars
;;   -> this could lead to information loss.
;;
;; Note:
;; Do *not* know, if thought about *all* nasty cases: strings is
;; complicated (and somewhat boring).


(define (j-NL)  "\n")
(define (j-sNL) ",\n")
(define (j-sS)  ", ")
(define (j-S)   " ")

;; without indent
(define (j-key-valStr-noquote keyStr valStr)
  (append "\"" keyStr "\":" (j-S) "\"" valStr "\""))
(define (j-key-valStr keyStr valStr)
  (j-key-valStr-noquote keyStr (json-quote valStr)))
(define (j-key-valJSON keyStr valJSONStr)
  (append "\"" keyStr "\":" (j-S) valJSONStr))
(define (j-keyQuoted-valJSON keyStr valJSONStr)
  (j-key-valJSON (json-quote keyStr) valJSONStr))

;; with indent
(define (ji-key-valStr keyStr valStr)
  (append iis (j-key-valStr keyStr valStr)))
(define (ji-key-valStr-noquote keyStr valStr)
  (append iis (j-key-valStr-noquote keyStr valStr)))
(define (ji-key-valJSON keyStr valJSONStr) ; valJSON used always with indent
  (append iis (j-key-valJSON keyStr valJSONStr)))

(set 'minimalOutput nil)
(if minimalOutput
    ;; minimal versions omitting JSON whitespace
    (set 'indentPlusStr ""
         'ois ""
         'iis ""
         'j-NL (lambda () "")
         'j-sNL (lambda () ",")
         'j-sS (lambda () ",")
         'j-S (lambda () "")
         ;; switch indent off
         'ji-key-valStr j-key-valStr
         'ji-key-valStr-noquote j-key-valStr-noquote
         'ji-key-valJSON j-key-valJSON)
    (set 'indentPlusStr "  " ; mandatory
         'ois "" ; needed by ji-* funcs (if not switched off), if not called ..
         'iis "")) ; .. via json-str/json-expr (which sets them)


;; shortcuts without indent
(define (j-type typeStr)
  (j-key-valStr-noquote "type" typeStr))
(define (j-val-valStr-noquote valStr)
  (j-key-valStr-noquote "val" valStr))
(define (j-val-valStr valStr)
  (j-key-valStr "val" valStr))
;; shortcuts with indent
(define (ji-type typeStr)
  (ji-key-valStr-noquote "type" typeStr))
(define (ji-val-valStr valStr)
  (ji-key-valStr "val" valStr))
(define (ji-val-valJSON valJSONStr)
  (ji-key-valJSON "val" valJSONStr))


(define (toJSON-simple-noquote typeStr arg)
  (append "{" (j-S)
          (j-type typeStr) (j-sS) (j-val-valStr-noquote (string arg))
          (j-S) "}"))
(define (toJSON-simple typeStr arg)
  (append "{" (j-S)
          (j-type typeStr) (j-sS) (j-val-valStr (string arg))
          (j-S) "}"))
(define (toJSON-simple-multiline typeStr arg)
  (append "{" (j-NL)
          (ji-type typeStr) (j-sNL)
          (ji-val-valStr (string arg)) (j-NL)
          ois "}"))

(define (j-obj-content contentStr)
  (append "{"
          (j-NL)
          contentStr
          (j-NL)
          ois "}"))

(define (j-typeObj-content typeStr contentStr
                           , (iis (append ois indentPlusStr)))
  (j-obj-content
   (append
    iis (j-type typeStr)
    (j-sNL)
    contentStr)))

(define (json-for-sym s fromOrNil
                      , (iis (append ois indentPlusStr))
                        (prefix_term (util:prefix-term-strings s))
                        (referenceFlag (!= (string (prefix s))
                                           (prefix_term 0))))
  (j-typeObj-content
   "sym"
   (append
    ;; iis indent
    (ji-key-valStr  "prefix"     (prefix_term 0))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valStr  "term"       (prefix_term 1))
    (j-sNL) ; with NL
    ;; iis indent
    (ji-key-valJSON "global?"    (if (global?    s) "true" "false"))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valJSON "protected?" (if (protected? s) "true" "false"))
    (j-sS) ; ', ' only
    ;; no indent
    (j-key-valJSON "reference" (if referenceFlag "true" "false"))
    (if referenceFlag
        (append
         (j-sS) ; ', ' only
         ;; no indent
         (j-key-valStr "target" (string (prefix s))))
        "")
    ;; we are interested in val of sym, but we want to avoid infinite recursion:
    ;; - sym_1 -> sym_2 -> sym_1
    (if (not (symbol? fromOrNil))
        (append
         (j-sNL) ; NL
         ;; iis indent
         (ji-val-valJSON (json-str (eval s) s iis)))
        ""))))

(define (json-for-context c
                          , (iis (append ois indentPlusStr)))
  (j-typeObj-content
   "context"
   (append
    (ji-key-valStr     "term"    (term c))
    (j-sNL)
    ;; no creation of default (functor) sym
    (ji-key-valJSON "default" (if (Util:default? c)
                                  "true"
                                  "null")))))

(define (json-for-lambda l
                         , (iis (append ois indentPlusStr)))
  (toJSON-simple-multiline "lambda" l))

(define (json-for-macro m
                        , (iis (append ois indentPlusStr)))
  (toJSON-simple-multiline "macro" m))

(define (json-for-listOrArray typeStr loa
                              , (iis (append ois indentPlusStr)))
  (j-typeObj-content
   typeStr
   (append
    (ji-key-valJSON "length" (string (length loa))) (j-sNL)
    (ji-key-valStr "rep" (string loa)))))

(macro (json-for-list L)
  (json-for-listOrArray "list" L))
(macro (json-for-array A)
  (json-for-listOrArray "array" A))


;; example source: "(set 'str \"bar\\000buz\")\n\n"
;; problematic:
;; - [text] does not show unprintable chars!
(define (extract-from-source sourceStr
                             , ixStart ixEnd strRaw)
  (set 'ixEnd -3
       'ixStart (find "\"|\\[" sourceStr 0) ; beginning of "\"" or "[text]"
       'strRaw (ixStart ixEnd sourceStr))
  (assert:post strRaw)
  strRaw)
;;
;;
;; check for unprintable chars works, if MAIN:string omits them
;; - don't know how to elegantly print set val of MAIN:source
(define (json-for-string str
                         , (iis (append ois indentPlusStr))
                           strVal strLen sourceStr)
  (set 'strVal (string str)
       'strLen (length str))
  (set 'sourceStr (source 'str))
  ;;(dbg:expr sourceStr)
  (j-typeObj-content
   "string"
   (append
    (ji-key-valJSON "length" (string (length str))) (j-sNL)
    (ji-key-valStr "rep" (extract-from-source sourceStr))
    (if (= (length strVal) strLen)
        "" ; str seems to be normal
        (append ; this one may have problems and/or interesting features
         (j-sNL)
         (ji-key-valJSON "unprintable chars" "true"))))))

(macro (em-json Def-or-Defmac Fun)
  (Def-or-Defmac (Fun a fromOrNil
                      (ois "") ; outer indent string
                      (iis (append ois ; iis in shared use
                                   indentPlusStr)))
    ;(dbg:expr a (symbol? a) (macro? a))
    (append
     (cond
      ((integer? a)
       (toJSON-simple-noquote "integer" a))
      ((bigint? a)
       (toJSON-simple-noquote "bigint" a))
      ((float? a)
       (toJSON-simple-noquote "float" a))
      ((string? a)
       (json-for-string a iis))
      ((quote? a)
       (toJSON-simple-noquote "quote" a))
      ((lambda? a)
       (json-for-lambda a))
      ((array? a)
       (json-for-array a))
      ((primitive? a)
       (toJSON-simple-noquote "primitive" a))
      ((context? a)
       (json-for-context a))
      ;; seq counts here
      ((symbol? a)
       (json-for-sym a fromOrNil))
      ((macro? a) ;&& seq counts: macro? for em-macro sym is true
       (json-for-macro a))
      ((list? a) ; a macro is a list, too
       (json-for-list a)) ; may call back with increased indent
      ((nil? a) ; (nil? 'nil) -> true
       (toJSON-simple-noquote "nil" a))
      ((true? a) ; (true? 'true) -> true
       (toJSON-simple-noquote "true" a))
      ("default"
       (throw-error (string "should not happen, unknown argument: " a))
       (toJSON-simple-noquote "unknown" a))))))


(em-json define json-str)
(em-json define-macro json-expr)


(define (render-symbols rname requestHeaders)
  (cons (symbols MAIN) "text/plain"))

(define (sym-actions s
                     , (prefixTerm (util:prefix-term-strings s)))
  (extend res
          (j-keyQuoted-valJSON ; json-quote for 'nasty' symbol names
           (append (prefixTerm 0) ":" (prefixTerm 1))
           (json-str s))))

(define (symbols-JSON rname rparams requestHeaders
                      , listSymStr listVal syms
                        valStr
                        res)
  ;;(dbg:expr rname rparams)
  ;; catch for val_nil:term constructs (leading to nil for failed catch/eval):
  ;; "ERR: context expected in function symbol? : val_nil"
  (if (and rparams (set 'listSymStr (lookup "inList" rparams)))
      (begin
        (set 'listVal (eval-string listSymStr))
        ;;(dbg:expr listSymStr listVal)
        (set 'syms
             (if (list? listVal)
                 (unique
                  (ref-all nil
                           listVal
                           (fn (ignore s) (if (catch (symbol? s) 'r) r nil))
                           true))
                 '()))) ; be robust against non-lists
      (set 'syms (util:symbols-all))) ; default
  ;;(dbg:expr syms)
  (if (and rparams
           (set 'valStr (lookup "noInspectorSymbols" rparams))
           (eval-string valStr))
      (set 'syms (clean (lambda (s) (= (prefix s) Inspector)) syms)))
  (set 'res "")
  (if syms (sym-actions (first syms)))
  (dolist (s (rest syms))
          (extend res ",\n")
          (sym-actions s))
  (cons (j-obj-content res) "application/json"))

(define (read-file-here file)
  ;;(dbg:expr (append Inspector:dir "/" file))
  (read-file (append Inspector:dir "/" file)))
(define (setup)
  (WS:create-eval-resource "symbols" 'render-symbols)
  (WS:create-eval-resource "symbols-JSON" 'symbols-JSON)

  (WS:create-static-resource "symbols.html" (read-file-here "symbols.html")
                             "text/html")
  (WS:create-static-resource "jquery-2.1.4.js" (read-file-here "jquery-2.1.4.js")
                             "text/javascript")
  (WS:create-static-resource "tree.jquery.js" (read-file-here "tree.jquery.js")
                             "text/javascript")


  (WS:create-static-resource "egBase.js" (read-file-here "egBase.js")
                             "text/javascript")
  (WS:create-static-resource "symbols.js" (read-file-here "symbols.js")
                             "text/javascript")
  (WS:create-static-resource "inspector.css" (read-file-here "inspector.css")
                             "text/css")

  (WS:create-static-resource "jqtree.css" (read-file-here "jqtree.css")
                             "text/css"))

(Inspector:setup)

(define (start (serverPort WS:server_port)) ; use WS default if no arg
  (WS:start serverPort))


(context MAIN)

(logg:level-all)
(set 'foo "bar")
(when true
(logg:info (Inspector:json-expr "foo"))
(logg:info (Inspector:json-str "foo"))
(dbg:expr (Inspector:json-str logg))
(dbg:expr (Inspector:json-expr logg))
(dbg:expr (Inspector:json-expr +))
(dbg:expr (Inspector:json-expr 4711))
(dbg:expr (Inspector:json-expr 'foo))
(dbg:expr (Inspector:json-str 'foo))
(dbg:expr (Inspector:json-str 'bar))
(dbg:expr (Inspector:json-str (array 6 '(1 2 3))))
(dbg:expr (Inspector:json-str nil))
(dbg:expr (Inspector:json-str 'nil))
(dbg:expr (Inspector:json-str default))
(dbg:expr (Inspector:json-str 'default))

(dbg:expr (Inspector:json-str logg))
(dbg:expr (Inspector:json-str 'logg))
(dbg:expr (Inspector:json-str MAIN))
(dbg:expr (Inspector:json-str 'MAIN))

(dbg:expr (Inspector:json-str true))
(dbg:expr (Inspector:json-str 'true))

(dbg:expr (Inspector:json-str "foo \"bar\" buz"))
)
;(define (bar))
;(dbg:off)

(set 's_0 "bar\000buz")
(set 's_1 "bar\u4711buz")
(set 's_2 "我能吞下玻璃而不伤身体。")
(set 's_3 (append (dup "this is a test" 250) "\n" (dup "this is a test" 250)))
(setq (s_3 5) "\000")
(set 's_4 "this is a test")
(setq (s_4 5) "\000")
(save "/tmp/s_3.lsp" 's_3)
(save "/tmp/s_4.lsp" 's_4)
(set 's_5 'aSym)
(set 's_5b ''aSymQuoted)
;; float test may make problems, if ',' (comma) is expected as fraction
;; separator
;;(set 's_6 3.1415926535)
(set 's_7 111111111111111111111111111111111111111111111111111111111)
(set 's_8 'dbg:expr)
(set 's_9 'dbg)
(set 's_10 ''dbg:expr)
(set 's_11 ''dbg)
(set 's_MAIN 'MAIN)
(set 's_str "\"")
(set 's_str2 "foo\"bar")

(set 's_s "\000\001\002\003\004\005\006\007\008\009\010\011\012\013\014\015\016\017\018\019\020\021\022\023\024\025\026\027\028\029\030\031\032\033\034\035\036\037\038\039\040\041\042\043\044")
(set 's_u "\u0000\u0001\u0002\u0003\u0004")
(set 's_v "foo\011bar")
(set 's_slash "\/")
(set 's_slash2 "\"foo\\/bar\"")
